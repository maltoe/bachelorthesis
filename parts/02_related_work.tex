\section{Related work}
\label{Related_work}

Related work of this thesis (in the narrow sense of the word, that is research about how to apply optimization techniques and SIMD programming to existing real-world applications) is hard to find. Tuomas Tonteri discussed the optimization of some scientific algorithms in~\cite{tonteri2012}. He explains in detail how SSE can be used to speed up N-particle dynamics simulation and ray sphere intersection testing, among others. Cort Stratton provided a case study on a SSE-optimized matrix-vector multiplier in~\cite{stratton2002}. In this article he gives a step-by-step report on how he iteratively improved the multiplication algorithm and in doing so explains the CPU provided levers for optimization such as instruction pairing and data prefetching. Guy Ben Haim et al. from Intel wrote an article~\cite{haim2009} about SSE optimization of an image processing algorithm. This again very detailed research gives some valuable insight on SSE-friendly characteristics of algorithms such as data layout and inherent parallelism.

Regarding instructional material about software optimization and specifically SSE utilization, one can find a wealth of works on the internet. Most notably, Danish researcher Agner Fog wrote five books about various aspects of software optimization that he continuously updates and publishes on his website\footnote{\url{http://www.agner.org/optimize/}, last accessed: \today{}}. These include a guide for high-level optimization with C++ and SSE intrinsics~\cite{fog2011optimizing} as well as a book~\cite{fog2011instructiontables} featuring exhaustive tables of instruction latencies and throughputs for almost all current CPU models, the clock cycles measured by Fog himself. The former will represent the foundation of the next section of this thesis.

Likewise comprehensive and well-structured is ``What every programmer should know about memory''~\cite{drepper2007memory} written by Ulrich Drepper. In this article the author examines in depth the technical details of random-access memory and presents ways for the developer to optimize his applications based on these specifics.

Intel produced their own optimization manual~\cite{intel2011manual} which is very extensive yet low-level and focussed on assembler language. Still, this is the most comprehensive source for information about how to completely exhaust Intel CPUs and understanding the assembler examples is a helpful preparation for doing high-level optimization. Apart from this, Intel offers lots of well-written articles through its \emph{Software Network}\footnote{\url{http://software.intel.com/en-us/articles/}, last accessed: \today{}}, although some of them are clearly targeted at compiler and low-level programmers.

Catalog-style information about x86 processors (e.g. instruction listings) can be found at sandpile.org\footnote{\url{http://sandpile.org}, last accessed: \today{}}. Reference documentation on SSE compiler intrinsics is provided by Intel in their extensive ``Intel 64 and IA-32 Architectures Software Developer Manual''~\cite{intel2012architectures}. Additionally, Intel distributes a handy desktop utility called ``Intel Intrinsics Guide''\footnote{Downloadable at \url{http://software.intel.com/en-us/avx/}, last accessed: \today{}}, which offers a browse and search interface for intrinsics and is especially helpful when working offline. Intrinsics are also well-documented at Microsoft's MSDN\footnote{\url{http://msdn.microsoft.com/en-us/library/26td21ds\%28v=vs.80\%29.aspx}, last accessed: \today{}}.
