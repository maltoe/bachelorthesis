[... SNIP ...]

In his instruction benchmarks~\cite[p. 44]{fog2011instructiontables} Agner Fog specifies the reciprocal throughput of \texttt{blendv} on the latest Intel "Sandy Bridge" processor architecture as 1, i.e. Intel processors can handle 1 \texttt{blendv} instruction per clock cycle if there are no data dependencies. The latency of \texttt{blendv} is 2, meaning that any succeeding instruction depending on the result of the current \texttt{blendv} instruction has to wait for 2 cycles before it can be processed. The \texttt{andps}, \texttt{andnps}, and \texttt{orps} instructions too have a reciprocal throughput of 1, yet have a lower latency, which is 1 as well. As \texttt{andnps} and \texttt{andps} could be executed in parallel, the complete logic triple takes 2 cycles, which is twice as much as a single \texttt{blendv} instruction. However, when used to vectorize longer sequences of nested conditional statements or \texttt{switch} statements, the higher latency comes into effect and performances of both solutions converge.

Table \ref{blending_table} displays the results of a simple benchmark application which measures the performance of the array sum example using these different blending techniques. Here, test A represents the known example with a single \texttt{if}-\texttt{else} statement, whereas test B contains two additional \texttt{else if} branches, so that a total of 4 different cases can occur. Both tests were run with random values and predictable values, which always triggered one of the cases. For these experiments, I set the compiler optimization to "-O2". The code of this benchmark can be found in Appendix REF. 

\begin{table}[h]
\begin{center}
\begin{tabular}{clcc}
\toprule
Task & Optimizations & Runtime (s), random & Runtime (s), predictable \\
\midrule
A & None & 0.0657 & 0.0658 \\
& Logical instructions & 0.0318 & 0.0320 \\
& \texttt{blendv} & 0.0274 & 0.0281 \\
\addlinespace
B & None & 0.431 & 0.065 \\
& Logical instructions & 0.081 & 0.081 \\
& \texttt{blendv} & 0.065 & 0.066 \\
& \texttt{blendv}, unrolled, prefetching & 0.061 & 0.061 \\
\bottomrule
\end{tabular}
\caption{Comparison of blending techniques for the array sum example}
\label{blending_table}
\end{center}
\end{table}

Note that these experiments do not measure performances of single instructions such as \texttt{blendv}, because various constant code parts, mainly fetching data from memory and the comparison operation, account for the bulk of the measured runtimes. Still, it shows that \texttt{blendv} is faster than a combination of logical operations and can be used for conditionals consisting of 2 or more branches. Apart from that, another important observation can be made here: There is a prominent discrepancy between random and predictable values processed by the not-optimized complex\footnote{Task B. Why does not happen this in example A?! Reason about this here.} conditional. This is an achievement of the branch prediction built into modern CPUs. It will quickly detect the simple pattern in the input data and always preload the correct instructions into the processor's pipeline. Obviously, as there are no branches in vectorized code, branch prediction can not come into effect. This ..
Second, there is a noticeable relative difference between the performance gains in example A and B. While the simple exa..

WAS ICH SAGEN WILL:
- branch prediction: Sorgt dafuer, dass gut vorhersagbare Spruenge nicht genommen werden, ergo ist vektorisierte (unbedingte) Ausfuehrung in manchen Faellen langsamer (z.B. wenn ein sprung nur in 1/1000 faellen genommen wird)
- lange if/else if/.../else o. switch statements: Spruenge sind ja auch gut. Sowas wird von SSE immer ausgefuehrt, normalerweise nich. vble\_opt hatte das in den Sektoren.
* der benchmark ist nicht gut. zu geringe komplexitaet, um den vorteil von jumps zu sehen.

- Ausserdem stimmt das anscheinend nicht: Hab einnen anderen test case, wo or(andn, and) und blendv bei einem einfachen if else statement exakt gleich auf sind, obwohl's theoretisch keine dependency chain gibt. Alles kaputt.

[... /SNIP ...]

early outs klar (blacklisting, NaN value detection, early out with ptest)